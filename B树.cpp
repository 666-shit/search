//
// Created by c1533 on 2022/9/21.
//
//五叉查找树
struct Node{
    int keys[4];        //最多4个关键字
    struct Node * child[5];     //最多5个孩子
    int num;        //结点中有几个关键字
};
//策略：m叉查找树中，除了根结点外，任何结点至少有[m/2]个分叉，即至少含有[m/2]-1个关键字
/**m阶B树核心特性：
 * 1. 根节点的子树数∈[2, m]，关键字数∈[1, m-1]，
 * 其他结点的子树数∈[[m/2], m]，关键字数∈[[m/2]-1, m-1]
 * 2. 对任意结点，所有子树高度都相同
 * 3. 关键字的值：子树0<子树1<子树2<……(类比二叉查找树)
 * */

/**B树高度
 * 含n个关键字的m阶b树，最小高度和最大高度为？
 *  至少有：2([m/2])^(k-1)层
 *  最多有：……
 * */
/**B树的插入
 * 5阶b树 结点关键字个数[m/2]-1<=n<=m-1
 * 插入key后，若导致原结点关键字数超过上限，则从中间位置[m/2]将其关键字分为两个部分，
 * 左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置的结点插入原结点的父结点；
 * 新元素一定是插入到最底层的终端结点，用查找来确定插入位置；
 * 父结点超出4个元素后，继续同第一步，向上拆分。
 * */

/**B树的删除
 * 若被删除的关键字再终端节点，则直接删除该关键字(注意关键字个数书否低于下限[m/2-1])
 * 若删除的关键字不在终端节点，则用直接前驱或直接后继代替这个关键字
 * 直接前驱：当前关键字左指针所指子树中最右下的元素
 *
 * 若终端结点数量低于下限(2个)，则：
 * 如果兄弟结点的关键字个数很宽裕(3个或4个)，则调整兄弟结点及其双亲结点(父子换位法)
 *      即：当右兄弟很宽裕时，用当前结点的后继(父第一个结点变兄弟)，
 *      后继的后继(父结点下面最小的结点变父结点)填补空缺
 * 如果兄弟结点的关键字不够借(2个)，则将关键字删除后与左/右兄弟及双亲结点中的关键字合并
 * 合并过程中，双亲结点数量小于下限，则合并双亲结点
 * */
