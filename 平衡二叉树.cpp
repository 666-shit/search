//
// Created by c1533 on 2022/9/19.
//
/**平衡二叉树
 * 平衡树(AVL)树上任一结点的左子树和右子树的高度差不超过1
 * 结点的平衡因子=左子树高-右子树高<=|1|
 * 重难点：插入新结点后如何调整不平衡的问题(选择题考)
 * */
//让二叉排序树达到平衡，就可以让其查找效率达到O(lov2_n)

typedef struct AVLNode {
    int key;
    int balance;
    struct AVLNode *lchild, *rchild;
} AVLNode, *AVLTree;
//插入一个元素后，查找路径上的所有结点都有可能收到影响
//从插入点往回找到第一个不平衡结点，调整以该结点为根的子树
/**调整最小不平衡子树
 * 原则：二叉排序树特性 BL<B<BR<A<AR
 * LL 在A的左孩子的左子树中插入导致不平衡    将A的左孩子B向右上旋转代替A成为根，将A结点向右下旋转成为B的右子树的根，而B的原右子树则作为A结点的左子树
 * RR          右孩子   右子树中插入导致不平衡             右            左                                                左                      左                            左                             右
 * LR          左孩子   右子树中插入导致不平衡    将A的左孩子B的右子树的根C向左上旋转提升到B位置，然后把C右上旋转到A
 * RL          右孩子   左子树中插入导致不平衡    不平衡结点的右孩子的左孩子，先右旋再左旋。
 * */
/**右旋代码思路(左旋类似)：
 * f是父结点，p是左孩子，gf为f的父结点
 * 1. f.lchild=p.rchild
 * 2. p.rchild=f
 * 3. gf.lchild/rchild=p
 * */
/**平衡二叉树的删除
 * 步骤：
 * 1. 删除结点(方法同二叉排序树)
 *      · 如果是叶子结点，直接删
 *      · 只有一个子树，子树顶替删除位置
 *      · 有两棵子树，用前驱或后继结点顶替，并转换为对前驱或后继的删除
 * 2. 向上找到最小不平衡子树，找不到则ok
 * 3. 找最小不平衡子树下，个头最高的儿子孙子
 * 4. 根据孙子结点位置，调整平衡树(LL RR LR RL)
 *      根据孙子位置调整平衡
 *      · 孙子LL：儿子右单旋
 *      · 孙子RR：儿子左单旋
 *      · 孙子LR：孙子先左旋，再右旋
 *      · 孙子RL：孙子先右旋，再左旋
 * 5. 如果不平衡向上传递，继续第二步
 * */
//删除操作时间复杂度：O(log2^n)
